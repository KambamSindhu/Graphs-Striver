
class Solution {
    public static int MinimumEffort(int rows, int columns, int[][] heights) {
      
      int[][] effort=new int[rows][columns];
      for(int i=0;i<rows;i++)
      {
          for(int j=0;j<columns;j++)
          {
              effort[i][j]=(int)1e9;
          }
      }
      
      effort[0][0]=0;
      PriorityQueue<Tuple> pq=new PriorityQueue<>(
          (x,y)->{
              return x.e-y.e;
          }
          );
      pq.add(new Tuple(0,0,0));
      
      int delrow[]={-1,0,1,0};
      int delcol[]={0,1,0,-1};
      while(!pq.isEmpty())
      {
          Tuple t=pq.remove();
          int e=t.e;
          int r=t.r;
          int c=t.c;
          if(r==rows-1 && c==columns-1)
          {
              return e;
          }
          for(int i=0;i<4;i++)
          {
              int nrow=delrow[i]+r;
              int ncol=delcol[i]+c;
              if(nrow>=0 && nrow<rows && ncol>=0 && ncol<columns)
              {
                int nval= Math.max(Math.abs(heights[nrow][ncol] - heights[r][c]), e);

                  
                  if(effort[nrow][ncol]>nval)
                  {
                     effort[nrow][ncol]=nval; 
                     pq.add(new Tuple(nval,nrow,ncol));
                  }
              }
          }
          
        
      }
        return 0;
    }
}
class Tuple{
    int e;
    int r;
    int c;
    Tuple(int e,int r,int c)
    {
        this.e=e;
        this.r=r;
        this.c=c;
    }
    
}
